<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>介绍 on 学而不思则罔</title>
    <link>https://cctrip.github.io/notes/</link>
    <description>Recent content in 介绍 on 学而不思则罔</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://cctrip.github.io/notes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Flannel</title>
      <link>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/network/flannel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/network/flannel/</guid>
      <description>Flannel #  UDP(Tunnel设备) #  TUN 设备是一种工作在三层（Network Layer）的虚拟网络设备。TUN 设备的功能非常简单，即：在操作系统内核和用户应用程序之间传递 IP 包。
 XVLAN #  通信原理 #    帧格式 #  Outer Ethernet Header: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Outer Destination MAC Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Outer Destination MAC Address | Outer Source MAC Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Outer Source MAC Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |OptnlEthtype = C-Tag 802.1Q | Outer.VLAN Tag Information | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Ethertype = 0x0800 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Outer IPv4 Header: #目的ip由flannel维护 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Version| IHL |Type of Service| Total Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Identification |Flags| Fragment Offset | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Time to Live |Protocl=17(UDP)| Header Checksum | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Outer Source IPv4 Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Outer Destination IPv4 Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Outer UDP Header: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Source Port | Dest Port = VXLAN Port | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | UDP Length | UDP Checksum | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ VXLAN Header: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |R|R|R|R|I|R|R|R| Reserved | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | VXLAN Network Identifier (VNI) | Reserved | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Inner Ethernet Header: #目的mac为flannel配置的网关地址的mac，由flannel下放到各个node上 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Inner Destination MAC Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Inner Destination MAC Address | Inner Source MAC Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Inner Source MAC Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |OptnlEthtype = C-Tag 802.</description>
    </item>
    
    <item>
      <title>oauth</title>
      <link>https://cctrip.github.io/notes/docs/technology/program/web/oauth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/web/oauth/</guid>
      <description>oauth #   OAuth是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。参考材料 RFC 6749。
 名词定义 #  在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。
 （1） Third-party application：第三方应用程序，本文中又称&amp;quot;客户端&amp;quot;（client），即上一节例子中的&amp;quot;云冲印&amp;quot;。
（2）HTTP service：HTTP服务提供商，本文中简称&amp;quot;服务提供商&amp;quot;，即上一节例子中的Google。
（3）Resource Owner：资源所有者，本文中又称&amp;quot;用户&amp;quot;（user）。
（4）User Agent：用户代理，本文中就是指浏览器。
（5）Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。
（6）Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。
 知道了上面这些名词，就不难理解，OAuth的作用就是让&amp;quot;客户端&amp;quot;安全可控地获取&amp;quot;用户&amp;quot;的授权，与&amp;quot;服务商提供商&amp;quot;进行互动。
 运行流程 #   +--------+ +---------------+ | |--(A)------- Authorization Grant ---------&amp;gt;| | | | | | | |&amp;lt;-(B)----------- Access Token -------------| | | | &amp;amp; Refresh Token | | | | | | | | +----------+ | | | |--(C)---- Access Token ----&amp;gt;| | | | | | | | | | | |&amp;lt;-(D)- Protected Resource --| Resource | | Authorization | | Client | | Server | | Server | | |--(E)---- Access Token ----&amp;gt;| | | | | | | | | | | |&amp;lt;-(F)- Invalid Token Error -| | | | | | +----------+ | | | | | | | |--(G)----------- Refresh Token -----------&amp;gt;| | | | | | | |&amp;lt;-(H)----------- Access Token -------------| | +--------+ &amp;amp; Optional Refresh Token +---------------+ （A）用户打开客户端以后，客户端要求用户给予授权。</description>
    </item>
    
    <item>
      <title>Pod</title>
      <link>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/object/workload/pod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/object/workload/pod/</guid>
      <description>Pod #  What #  Pod 是 Kubernetes 应用程序的基本执行单元，即它是 Kubernetes 对象模型中创建或部署的最小和最简单的单元。Pod 表示在 集群 上运行的进程。
Pod 封装了应用程序容器（或者在某些情况下封装多个容器）、存储资源、唯一网络 IP 以及控制容器应该如何运行的选项。 Pod 表示部署单元：Kubernetes 中应用程序的单个实例，它可能由单个 容器 或少量紧密耦合并共享资源的容器组成。
 Docker 是 Kubernetes Pod 中最常用的容器运行时，但 Pod 也能支持其他的 容器运行时。
Kubernetes 集群中的 Pod 可被用于以下两个主要用途：
  运行单个容器的 Pod。&amp;ldquo;每个 Pod 一个容器&amp;quot;模型是最常见的 Kubernetes 用例；在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。
  运行多个协同工作的容器的 Pod。 Pod 可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。 这些位于同一位置的容器可能形成单个内聚的服务单元 —— 一个容器将文件从共享卷提供给公众，而另一个单独的“挂斗”（sidecar）容器则刷新或更新这些文件。 Pod 将这些容器和存储资源打包为一个可管理的实体。 Kubernetes 博客 上有一些其他的 Pod 用例信息。更多信息请参考：
   分布式系统工具包：容器组合的模式</description>
    </item>
    
    <item>
      <title>Redis集群</title>
      <link>https://cctrip.github.io/notes/docs/technology/database/nosql/redis/cluster/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/database/nosql/redis/cluster/</guid>
      <description>集群 #  集群搭建 #    Redis安装
wget http://download.redis.io/releases/redis-4.0.1.tar.gz    基础配置
#除端口外，配置统一 #common port 6379 pidfile /cache1/redis/6379/redis_6379.pid loglevel notice logfile &amp;quot;/cache1/redis/6379/redis_6379.log&amp;quot; dir /cache1/redis/6379 protected-mode no #rdb save 7200 1000 rdbcompression yes rdbchecksum yes dbfilename dump.rdb #aof appendonly yes appendfilename &amp;quot;appendonly.aof&amp;quot; #cluster cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000    redis集群架构
192.168.88.1:6379(master) 192.168.88.2:6379(slave) 192.168.88.2:6378(master) 192.168.88.3:6378(slave) 192.168.88.3:6377(master) 192.168.88.1:6377(slave)    启动redis
cd $PATH redis-server redis-6379.conf &amp;amp;    集群管理器安装</description>
    </item>
    
    <item>
      <title>内核参数优化</title>
      <link>https://cctrip.github.io/notes/docs/technology/system/linux/kernel/opt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/system/linux/kernel/opt/</guid>
      <description>参数优化 #  vm.swappiness = 0 net.ipv4.neigh.default.gc_stale_time=120 # see details in https://help.aliyun.com/knowledge_detail/39428.html net.ipv4.conf.all.rp_filter=0 net.ipv4.conf.default.rp_filter=0 net.ipv4.conf.default.arp_announce = 2 net.ipv4.conf.lo.arp_announce=2 net.ipv4.conf.all.arp_announce=2 # see details in https://help.aliyun.com/knowledge_detail/41334.html net.ipv4.tcp_max_tw_buckets = 5000 net.ipv4.tcp_synack_retries = 2 net.ipv6.conf.all.disable_ipv6 = 1 net.ipv6.conf.default.disable_ipv6 = 1 net.ipv6.conf.lo.disable_ipv6 = 1 net.core.rmem_default = 256960 net.core.rmem_max = 513920 net.core.wmem_default = 256960 net.core.wmem_max = 513920 net.core.netdev_max_backlog = 2000 net.core.somaxconn = 2048 net.core.optmem_max = 81920 net.ipv4.tcp_mem = 131072 262144 524288 net.ipv4.tcp_rmem = 8760 256960 4088000 net.</description>
    </item>
    
    <item>
      <title>实践论</title>
      <link>https://cctrip.github.io/notes/docs/other/read/%E5%AE%9E%E8%B7%B5%E8%AE%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/other/read/%E5%AE%9E%E8%B7%B5%E8%AE%BA/</guid>
      <description>实践论 #  论认识和实践的关系——知和行的关系 #  （一九三七年七月）
 在中国共产党内，曾经有一部分教条主义的同志长期拒绝中国革命的经验，否认“马克思主义不是教条而是行动的指南”这个真理，而只生吞活剥马克思主义书籍中的只言片语，去吓唬人们。还有另一部分经验主义的同志长期拘守于自身的片断经验，不了解理论对于革命实践的重要性，看不见革命的全局，虽然也是辛苦地——但却是盲目地在工作。这两类同志的错误思想，特别是教条主义思想，曾经在一九三一年至一九三四年使得中国革命受了极大的损失，而教条主义者却是披着马克思主义的外衣迷惑了广大的同志。毛泽东的《实践论》，是为着用马克思主义的认识论观点去揭露党内的教条主义和经验主义——特别是教条主义这些主观主义的错误而写的。因为重点是揭露看轻实践的教条主义这种主观主义，故题为《实践论》。毛泽东曾以这篇论文的观点在延安的抗日军事政治大学作过讲演。
 　马克思以前的唯物论，离开人的社会性，离开人的历史发展，去观察认识问题，因此不能了解认识对社会实践的依赖关系，即认识对生产和阶级斗争的依赖关系。
首先，马克思主义者认为人类的生产活动是最基本的实践活动，是决定其他一切活动的东西。人的认识，主要地依赖于物质的生产活动，逐渐地了解自然的现象、自然的性质、自然的规律性、人和自然的关系；而且经过生产活动，也在各种不同程度上逐渐地认识了人和人的一定的相互关系。一切这些知识，离开生产活动是不能得到的。在没有阶级的社会中，每个人以社会一员的资格，同其他社会成员协力，结成一定的生产关系，从事生产活动，以解决人类物质生活问题。在各种阶级的社会中，各阶级的社会成员，则又以各种不同的方式，结成一定的生产关系，从事生产活动，以解决人类物质生活问题。这是人的认识发展的基本来源。
人的社会实践，不限于生产活动一种形式，还有多种其他的形式，阶级斗争，政治生活，科学和艺术的活动，总之社会实际生活的一切领域都是社会的人所参加的。因此，人的认识，在物质生活以外，还从政治生活文化生活中（与物质生活密切联系），在各种不同程度上，知道人和人的各种关系。其中，尤以各种形式的阶级斗争，给予人的认识发展以深刻的影响。在阶级社会中，每一个人都在一定的阶级地位中生活，各种思想无不打上阶级的烙印。
马克思主义者认为人类社会的生产活动，是一步又一步地由低级向高级发展，因此，人们的认识，不论对于自然界方面，对于社会方面，也都是一步又一步地由低级向高级发展，即由浅入深，由片面到更多的方面。在很长的历史时期内，大家对于社会的历史只能限于片面的了解，这一方面是由于剥削阶级的偏见经常歪曲社会的历史，另方面，则由于生产规模的狭小，限制了人们的眼界。人们能够对于社会历史的发展作全面的历史的了解，把对于社会的认识变成了科学，这只是到了伴随巨大生产力——大工业而出现近代无产阶级的时候，这就是马克思主义的科学。
马克思主义者认为，只有人们的社会实践，才是人们对于外界认识的真理性的标准。实际的情形是这样的，只有在社会实践过程中（物质生产过程中，阶级斗争过程中，科学实验过程中），人们达到了思想中所预想的结果时，人们的认识才被证实了。人们要想得到工作的胜利即得到预想的结果，一定要使自己的思想合于客观外界的规律性，如果不合，就会在实践中失败。人们经过失败之后，也就从失败取得教训，改正自己的思想使之适合于外界的规律性，人们就能变失败为胜利，所谓“失败者成功之母”，“吃一堑长一智”，就是这个道理。辩证唯物论的认识论把实践提到第一的地位，认为人的认识一点也不能离开实践，排斥一切否认实践重要性、使认识离开实践的错误理论。列宁这样说过：“实践高于（理论的）认识，因为它不但有普遍性的品格，而且还有直接现实性的品格。”⑴马克思主义的哲学辩证唯物论有两个最显著的特点：一个是它的阶级性，公然申明辩证唯物论是为无产阶级服务的；再一个是它的实践性，强调理论对于实践的依赖关系，理论的基础是实践，又转过来为实践服务。判定认识或理论之是否真理，不是依主观上觉得如何而定，而是依客观上社会实践的结果如何而定。真理的标准只能是社会的实践。实践的观点是辩证唯物论的认识论之第一的和基本的观点⑵。
然而人的认识究竟怎样从实践发生，而又服务于实践呢？这只要看一看认识的发展过程就会明了的。
原来人在实践过程中，开始只是看到过程中各个事物的现象方面，看到各个事物的片面，看到各个事物之间的外部联系。例如有些外面的人们到延安来考察，头一二天，他们看到了延安的地形、街道、屋宇，接触了许多的人，参加了宴会、晚会和群众大会，听到了各种说话，看到了各种文件，这些就是事物的现象，事物的各个片面以及这些事物的外部联系。这叫做认识的感性阶段，就是感觉和印象的阶段。也就是延安这些各别的事物作用于考察团先生们的感官，引起了他们的感觉，在他们的脑子中生起了许多的印象，以及这些印象间的大概的外部的联系，这是认识的第一个阶段。在这个阶段中，人们还不能造成深刻的概念，作出合乎论理（即合乎逻辑）的结论。
社会实践的继续，使人们在实践中引起感觉和印象的东西反复了多次，于是在人们的脑子里生起了一个认识过程中的突变（即飞跃），产生了概念。概念这种东西已经不是事物的现象，不是事物的各个片面，不是它们的外部联系，而是抓着了事物的本质，事物的全体，事物的内部联系了。概念同感觉，不但是数量上的差别，而且有了性质上的差别。循此继进，使用判断和推理的方法，就可产生出合乎论理的结论来。《三国演义》上所谓“眉头一皱计上心来”，我们普通说话所谓“让我想一想”，就是人在脑子中运用概念以作判断和推理的工夫。这是认识的第二个阶段。外来的考察团先生们在他们集合了各种材料，加上他们“想了一想”之后，他们就能够作出“共产党的抗日民族统一战线的政策是彻底的、诚恳的和真实的”这样一个判断了。在他们作出这个判断之后，如果他们对于团结救国也是真实的的话，那末他们就能够进一步作出这样的结论：“抗日民族统一战线是能够成功的。”这个概念、判断和推理的阶段，在人们对于一个事物的整个认识过程中是更重要的阶段，也就是理性认识的阶段。认识的真正任务在于经过感觉而到达于思维，到达于逐步了解客观事物的内部矛盾，了解它的规律性，了解这一过程和那一过程间的内部联系，即到达于论理的认识。重复地说，论理的认识所以和感性的认识不同，是因为感性的认识是属于事物之片面的、现象的、外部联系的东西，论理的认识则推进了一大步，到达了事物的全体的、本质的、内部联系的东西，到达了暴露周围世界的内在的矛盾，因而能在周围世界的总体上，在周围世界一切方面的内部联系上去把握周围世界的发展。
这种基于实践的由浅入深的辩证唯物论的关于认识发展过程的理论，在马克思主义以前，是没有一个人这样解决过的。马克思主义的唯物论，第一次正确地解决了这个问题，唯物地而且辩证地指出了认识的深化的运动，指出了社会的人在他们的生产和阶级斗争的复杂的、经常反复的实践中，由感性认识到论理认识的推移的运动。列宁说过：“物质的抽象，自然规律的抽象，价值的抽象以及其他等等，一句话，一切科学的（正确的、郑重的、非瞎说的）抽象，都更深刻、更正确、更完全地反映着自然。”⑶马克思列宁主义认为：认识过程中两个阶段的特性，在低级阶段，认识表现为感性的，在高级阶段，认识表现为论理的，但任何阶段，都是统一的认识过程中的阶段。感性和理性二者的性质不同，但又不是互相分离的，它们在实践的基础上统一起来了。我们的实践证明：感觉到了的东西，我们不能立刻理解它，只有理解了的东西才更深刻地感觉它。感觉只解决现象问题，理论才解决本质问题。这些问题的解决，一点也不能离开实践。无论何人要认识什么事物，除了同那个事物接触，即生活于（实践于）那个事物的环境中，是没有法子解决的。不能在封建社会就预先认识资本主义社会的规律，因为资本主义还未出现，还无这种实践。马克思主义只能是资本主义社会的产物。马克思不能在自由资本主义时代就预先具体地认识帝国主义时代的某些特异的规律，因为帝国主义这个资本主义最后阶段还未到来，还无这种实践，只有列宁和斯大林才能担当此项任务。马克思、恩格斯、列宁、斯大林之所以能够作出他们的理论，除了他们的天才条件之外，主要地是他们亲自参加了当时的阶级斗争和科学实验的实践，没有这后一个条件，任何天才也是不能成功的。“秀才不出门，全知天下事”，在技术不发达的古代只是一句空话，在技术发达的现代虽然可以实现这句话，然而真正亲知的是天下实践着的人，那些人在他们的实践中间取得了“知”，经过文字和技术的传达而到达于“秀才”之手，秀才乃能间接地“知天下事”。如果要直接地认识某种或某些事物，便只有亲身参加于变革现实、变革某种或某些事物的实践的斗争中，才能触到那种或那些事物的现象，也只有在亲身参加变革现实的实践的斗争中，才能暴露那种或那些事物的本质而理解它们。这是任何人实际上走着的认识路程，不过有些人故意歪曲地说些反对的话罢了。世上最可笑的是那些“知识里手”⑷，有了道听途说的一知半解，便自封为“天下第一”，适足见其不自量而已。知识的问题是一个科学问题，来不得半点的虚伪和骄傲，决定地需要的倒是其反面——诚实和谦逊的态度。你要有知识，你就得参加变革现实的实践。你要知道梨子的滋味，你就得变革梨子，亲口吃一吃。你要知道原子的组织同性质，你就得实行物理学和化学的实验，变革原子的情况。你要知道革命的理论和方法，你就得参加革命。一切真知都是从直接经验发源的。但人不能事事直接经验，事实上多数的知识都是间接经验的东西，这就是一切古代的和外域的知识。这些知识在古人在外人是直接经验的东西，如果在古人外人直接经验时是符合于列宁所说的条件“科学的抽象”，是科学地反映了客观的事物，那末这些知识是可靠的，否则就是不可靠的。所以，一个人的知识，不外直接经验的和间接经验的两部分。而且在我为间接经验者，在人则仍为直接经验。因此，就知识的总体说来，无论何种知识都是不能离开直接经验的。任何知识的来源，在于人的肉体感官对客观外界的感觉，否认了这个感觉，否认了直接经验，否认亲自参加变革现实的实践，他就不是唯物论者。“知识里手”之所以可笑，原因就是在这个地方。中国人有一句老话：“不入虎穴，焉得虎子。”这句话对于人们的实践是真理，对于认识论也是真理。离开实践的认识是不可能的。
为了明了基于变革现实的实践而产生的辩证唯物论的认识运动——认识的逐渐深化的运动，下面再举出几个具体的例子。
无产阶级对于资本主义社会的认识，在其实践的初期——破坏机器和自发斗争时期，他们还只在感性认识的阶段，只认识资本主义各个现象的片面及其外部的联系。这时，他们还是一个所谓“自在的阶级”。但是到了他们实践的第二个时期——有意识有组织的经济斗争和政治斗争的时期，由于实践，由于长期斗争的经验，经过马克思、恩格斯用科学的方法把这种种经验总结起来，产生了马克思主义的理论，用以教育无产阶级，这样就使无产阶级理解了资本主义社会的本质，理解了社会阶级的剥削关系，理解了无产阶级的历史任务，这时他们就变成了一个“自为的阶级”。
中国人民对于帝国主义的认识也是这样。第一阶段是表面的感性的认识阶段，表现在太平天国运动和义和团运动等笼统的排外主义的斗争上⑸。第二阶段才进到理性的认识阶段，看出了帝国主义内部和外部的各种矛盾，并看出了帝国主义联合中国买办阶级和封建阶级以压榨中国人民大众的实质，这种认识是从一九一九年五四运动⑹前后才开始的。
我们再来看战争。战争的领导者，如果他们是一些没有战争经验的人，对于一个具体的战争（例如我们过去十年的土地革命战争）的深刻的指导规律，在开始阶段是不了解的。他们在开始阶段只是身历了许多作战的经验，而且败仗是打得很多的。然而由于这些经验（胜仗，特别是败仗的经验），使他们能够理解贯串整个战争的内部的东西，即那个具体战争的规律性，懂得了战略和战术，因而能够有把握地去指导战争。此时，如果改换一个无经验的人去指导，又会要在吃了一些败仗之后（有了经验之后）才能理会战争的正确的规律。
常常听到一些同志在不能勇敢接受工作任务时说出来的一句话：没有把握。为什么没有把握呢？因为他对于这项工作的内容和环境没有规律性的了解，或者他从来就没有接触过这类工作，或者接触得不多，因而无从谈到这类工作的规律性。及至把工作的情况和环境给以详细分析之后，他就觉得比较地有了把握，愿意去做这项工作。如果这个人在这项工作中经过了一个时期，他有了这项工作的经验了，而他又是一个肯虚心体察情况的人，不是一个主观地、片面地、表面地看问题的人，他就能够自己做出应该怎样进行工作的结论，他的工作勇气也就可以大大地提高了。只有那些主观地、片面地和表面地看问题的人，跑到一个地方，不问环境的情况，不看事情的全体（事情的历史和全部现状），也不触到事情的本质（事情的性质及此一事情和其他事情的内部联系），就自以为是地发号施令起来，这样的人是没有不跌交子的。
由此看来，认识的过程，第一步，是开始接触外界事情，属于感觉的阶段。第二步，是综合感觉的材料加以整理和改造，属于概念、判断和推理的阶段。只有感觉的材料十分丰富（不是零碎不全）和合于实际（不是错觉），才能根据这样的材料造出正确的概念和论理来。
这里有两个要点必须着重指明。第一个，在前面已经说过的，这里再重复说一说，就是理性认识依赖于感性认识的问题。如果以为理性认识可以不从感性认识得来，他就是一个唯心论者。哲学史上有所谓“唯理论”一派，就是只承认理性的实在性，不承认经验的实在性，以为只有理性靠得住，而感觉的经验是靠不住的，这一派的错误在于颠倒了事实。理性的东西所以靠得住，正是由于它来源于感性，否则理性的东西就成了无源之水，无本之木，而只是主观自生的靠不住的东西了。从认识过程的秩序说来，感觉经验是第一的东西，我们强调社会实践在认识过程中的意义，就在于只有社会实践才能使人的认识开始发生，开始从客观外界得到感觉经验。一个闭目塞听、同客观外界根本绝缘的人，是无所谓认识的。认识开始于经验——这就是认识论的唯物论。
第二是认识有待于深化，认识的感性阶段有待于发展到理性阶段——这就是认识论的辩证法⑺。如果以为认识可以停顿在低级的感性阶段，以为只有感性认识可靠，而理性认识是靠不住的，这便是重复了历史上的“经验论”的错误。这种理论的错误，在于不知道感觉材料固然是客观外界某些真实性的反映（我这里不来说经验只是所谓内省体验的那种唯心的经验论），但它们仅是片面的和表面的东西，这种反映是不完全的，是没有反映事物本质的。要完全地反映整个的事物，反映事物的本质，反映事物的内部规律性，就必须经过思考作用，将丰富的感觉材料加以去粗取精、去伪存真、由此及彼、由表及里的改造制作工夫，造成概念和理论的系统，就必须从感性认识跃进到理性认识。这种改造过的认识，不是更空虚了更不可靠了的认识，相反，只要是在认识过程中根据于实践基础而科学地改造过的东西，正如列宁所说乃是更深刻、更正确、更完全地反映客观事物的东西。庸俗的事务主义家不是这样，他们尊重经验而看轻理论，因而不能通观客观过程的全体，缺乏明确的方针，没有远大的前途，沾沾自喜于一得之功和一孔之见。这种人如果指导革命，就会引导革命走上碰壁的地步。
理性认识依赖于感性认识，感性认识有待于发展到理性认识，这就是辩证唯物论的认识论。哲学上的“唯理论”和“经验论”都不懂得认识的历史性或辩证性，虽然各有片面的真理（对于唯物的唯理论和经验论而言，非指唯心的唯理论和经验论），但在认识论的全体上则都是错误的。由感性到理性之辩证唯物论的认识运动，对于一个小的认识过程（例如对于一个事物或一件工作的认识）是如此，对于一个大的认识过程（例如对于一个社会或一个革命的认识）也是如此。
然而认识运动至此还没有完结。辩证唯物论的认识运动，如果只到理性认识为止，那末还只说到问题的一半。而且对于马克思主义的哲学说来，还只说到非十分重要的那一半。马克思主义的哲学认为十分重要的问题，不在于懂得了客观世界的规律性，因而能够解释世界，而在于拿了这种对于客观规律性的认识去能动地改造世界。在马克思主义看来，理论是重要的，它的重要性充分地表现在列宁说过的一句话：“没有革命的理论，就不会有革命的运动。”⑻然而马克思主义看重理论，正是，也仅仅是，因为它能够指导行动。如果有了正确的理论，只是把它空谈一阵，束之高阁，并不实行，那末，这种理论再好也是没有意义的。认识从实践始，经过实践得到了理论的认识，还须再回到实践去。认识的能动作用，不但表现于从感性的认识到理性的认识之能动的飞跃，更重要的还须表现于从理性的认识到革命的实践这一个飞跃。抓着了世界的规律性的认识，必须把它再回到改造世界的实践中去，再用到生产的实践、革命的阶级斗争和民族斗争的实践以及科学实验的实践中去。这就是检验理论和发展理论的过程，是整个认识过程的继续。理论的东西之是否符合于客观真理性这个问题，在前面说的由感性到理性之认识运动中是没有完全解决的，也不能完全解决的。要完全地解决这个问题，只有把理性的认识再回到社会实践中去，应用理论于实践，看它是否能够达到预想的目的。许多自然科学理论之所以被称为真理，不但在于自然科学家们创立这些学说的时候，而且在于为尔后的科学实践所证实的时候。马克思列宁主义之所以被称为真理，也不但在于马克思、恩格斯、列宁、斯大林等人科学地构成这些学说的时候，而且在于为尔后革命的阶级斗争和民族斗争的实践所证实的时候。辩证唯物论之所以为普遍真理，在于经过无论什么人的实践都不能逃出它的范围。人类认识的历史告诉我们，许多理论的真理性是不完全的，经过实践的检验而纠正了它们的不完全性。许多理论是错误的，经过实践的检验而纠正其错误。所谓实践是真理的标准，所谓“生活、实践底观点，应该是认识论底首先的和基本的观点”⑼，理由就在这个地方。斯大林说得好：“理论若不和革命实践联系起来，就会变成无对象的理论，同样，实践若不以革命理论为指南，就会变成盲目的实践。”⑽
说到这里，认识运动就算完成了吗？我们的答复是完成了，又没有完成。社会的人们投身于变革在某一发展阶段内的某一客观过程的实践中（不论是关于变革某一自然过程的实践，或变革某一社会过程的实践），由于客观过程的反映和主观能动性的作用，使得人们的认识由感性的推移到了理性的，造成了大体上相应于该客观过程的法则性的思想、理论、计划或方案，然后再应用这种思想、理论、计划或方案于该同一客观过程的实践，如果能够实现预想的目的，即将预定的思想、理论、计划、方案在该同一过程的实践中变为事实，或者大体上变为事实，那末，对于这一具体过程的认识运动算是完成了。例如，在变革自然的过程中，某一工程计划的实现，某一科学假想的证实，某一器物的制成，某一农产的收获，在变革社会过程中某一罢工的胜利，某一战争的胜利，某一教育计划的实现，都算实现了预想的目的。然而一般地说来，不论在变革自然或变革社会的实践中，人们原定的思想、理论、计划、方案，毫无改变地实现出来的事，是很少的。这是因为从事变革现实的人们，常常受着许多的限制，不但常常受着科学条件和技术条件的限制，而且也受着客观过程的发展及其表现程度的限制（客观过程的方面及本质尚未充分暴露）。在这种情形之下，由于实践中发现前所未料的情况，因而部分地改变思想、理论、计划、方案的事是常有的，全部地改变的事也是有的。即是说，原定的思想、理论、计划、方案，部分地或全部地不合于实际，部分错了或全部错了的事，都是有的。许多时候须反复失败过多次，才能纠正错误的认识，才能到达于和客观过程的规律性相符合，因而才能够变主观的东西为客观的东西，即在实践中得到预想的结果。但是不管怎样，到了这种时候，人们对于在某一发展阶段内的某一客观过程的认识运动，算是完成了。
然而对于过程的推移而言，人们的认识运动是没有完成的。任何过程，不论是属于自然界的和属于社会的，由于内部的矛盾和斗争，都是向前推移向前发展的，人们的认识运动也应跟着推移和发展。依社会运动来说，真正的革命的指导者，不但在于当自己的思想、理论、计划、方案有错误时须得善于改正，如同上面已经说到的，而且在于当某一客观过程已经从某一发展阶段向另一发展阶段推移转变的时候，须得善于使自己和参加革命的一切人员在主观认识上也跟着推移转变，即是要使新的革命任务和新的工作方案的提出，适合于新的情况的变化。革命时期情况的变化是很急速的，如果革命党人的认识不能随之而急速变化，就不能引导革命走向胜利。
然而思想落后于实际的事是常有的，这是因为人的认识受了许多社会条件的限制的缘故。我们反对革命队伍中的顽固派，他们的思想不能随变化了的客观情况而前进，在历史上表现为右倾机会主义。这些人看不出矛盾的斗争已将客观过程推向前进了，而他们的认识仍然停止在旧阶段。一切顽固党的思想都有这样的特征。他们的思想离开了社会的实践，他们不能站在社会车轮的前头充任向导的工作，他们只知跟在车子后面怨恨车子走得太快了，企图把它向后拉，开倒车。
我们也反对“左”翼空谈主义。他们的思想超过客观过程的一定发展阶段，有些把幻想看作真理，有些则把仅在将来有现实可能性的理想，勉强地放在现时来做，离开了当前大多数人的实践，离开了当前的现实性，在行动上表现为冒险主义。
唯心论和机械唯物论，机会主义和冒险主义，都是以主观和客观相分裂，以认识和实践相脱离为特征的。以科学的社会实践为特征的马克思列宁主义的认识论，不能不坚决反对这些错误思想。马克思主义者承认，在绝对的总的宇宙发展过程中，各个具体过程的发展都是相对的，因而在绝对真理的长河中，人们对于在各个一定发展阶段上的具体过程的认识只具有相对的真理性。无数相对的真理之总和，就是绝对的真理⑾。客观过程的发展是充满着矛盾和斗争的发展，人的认识运动的发展也是充满着矛盾和斗争的发展。一切客观世界的辩证法的运动，都或先或后地能够反映到人的认识中来。社会实践中的发生、发展和消灭的过程是无穷的，人的认识的发生、发展和消灭的过程也是无穷的。根据于一定的思想、理论、计划、方案以从事于变革客观现实的实践，一次又一次地向前，人们对于客观现实的认识也就一次又一次地深化。客观现实世界的变化运动永远没有完结，人们在实践中对于真理的认识也就永远没有完结。马克思列宁主义并没有结束真理，而是在实践中不断地开辟认识真理的道路。我们的结论是主观和客观、理论和实践、知和行的具体的历史的统一，反对一切离开具体历史的“左”的或右的错误思想。
社会的发展到了今天的时代，正确地认识世界和改造世界的责任，已经历史地落在无产阶级及其政党的肩上。这种根据科学认识而定下来的改造世界的实践过程，在世界、在中国均已到达了一个历史的时节——自有历史以来未曾有过的重大时节，这就是整个儿地推翻世界和中国的黑暗面，把它们转变过来成为前所未有的光明世界。无产阶级和革命人民改造世界的斗争，包括实现下述的任务：改造客观世界，也改造自己的主观世界——改造自己的认识能力，改造主观世界同客观世界的关系。地球上已经有一部分实行了这种改造，这就是苏联。他们还正在促进这种改造过程。中国人民和世界人民也都正在或将要通过这样的改造过程。所谓被改造的客观世界，其中包括了一切反对改造的人们，他们的被改造，须要通过强迫的阶段，然后才能进入自觉的阶段。世界到了全人类都自觉地改造自己和改造世界的时候，那就是世界的共产主义时代。
通过实践而发现真理，又通过实践而证实真理和发展真理。从感性认识而能动地发展到理性认识，又从理性认识而能动地指导革命实践，改造主观世界和客观世界。实践、认识、再实践、再认识，这种形式，循环往复以至无穷，而实践和认识之每一循环的内容，都比较地进到了高一级的程度。这就是辩证唯物论的全部认识论，这就是辩证唯物论的知行统一观。
 　注　释
〔1〕见列宁《黑格尔〈逻辑学〉一书摘要》。新的译文是：“实践高于（理论的）认识，因为它不仅具有普遍性的品格，而且还具有直接现实性的品格。”（《列宁全集》第55卷，人民出版社1990年版，第183页）
〔2〕参见马克思《关于费尔巴哈的提纲》（《马克思恩格斯选集》第1卷，人民出版社1972年版，第16—19页）和列宁《唯物主义和经验批判主义》第二章第六节（《列宁全集》第18卷，人民出版社1988年版，第144页）。
〔3〕 见列宁《黑格尔〈逻辑学〉一书摘要》（《列宁全集》第55卷，人民出版社1990年版，第142页）。
〔4〕里手，湖南方言，内行的意思。
〔5〕一九五一年三月二十七日，毛泽东在致李达的信中说：“《实践论》中将太平天国放在排外主义一起说不妥，出选集时拟加修改，此处暂仍照原。”
〔6〕五四运动是一九一九年五月四日发生的反帝反封建的爱国运动。当时，第一次世界大战刚刚结束，英、美、法、日、意等战胜国在巴黎召开对德和会，决定由日本继承德国在中国山东的特权。中国是参加对德宣战的战胜国之一，但北洋军阀政府却准备接受这个决定。五月四日，北京学生游行示威，反对帝国主义的这一无理决定和北洋军阀政府的妥协。这次运动迅速地获得了全国人民的响应，到六月三日以后，发展成为有工人阶级、城市小资产阶级和民族资产阶级参加的广大群众性的反帝反封建的爱国运动。五四运动也是反对封建文化的新文化运动。以一九一五年《青年杂志》（后改名《新青年》）创刊为起点的新文化运动，竖起“民主”和“科学”的旗帜，反对旧道德，提倡新道德，反对旧文学，提倡新文学。五四运动中的先进分子接受了马克思主义，使新文化运动发展成为马克思主义思想运动，他们致力于马克思主义同中国工人运动相结合，在思想上和干部上准备了中国共产党的成立。
〔7〕参见列宁《黑格尔〈逻辑学〉一书摘要》：“要理解，就必须从经验开始理解、研究，从经验上升到一般。”（《列宁全集》第55卷，人民出版社1990年版，第175页）
〔8〕见列宁《俄国社会民主党人的任务》（《列宁全集》第2卷，人民出版社1984年版，第443页）；并见列宁《怎么办？》第一章第四节（《列宁全集》第6卷，人民出版社1986年版，第23页）。
〔9〕 见列宁《唯物主义和经验批判主义》第二章第六节（《列宁全集》第18卷，人民出版社1988年版，第144页）。
〔10〕见斯大林《论列宁主义基础》第三部分《理论》。新的译文是：“离开革命实践的理论是空洞的理论，而不以革命理论为指南的实践是盲目的实践。”（《斯大林选集》上卷，人民出版社1979年版，第199—200页）
〔11〕参见列宁《唯物主义和经验批判主义》第二章第五节。原文是：“人类思维按其本性是能够给我们提供并且正在提供由相对真理的总和所构成的绝对真理的。”（《列宁全集》第18卷，人民出版社1988年版，第135页）</description>
    </item>
    
    <item>
      <title>技能图谱</title>
      <link>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/map/</guid>
      <description>Kubernetes 技能图谱 #  Container basics （容器技术基础） #   Linux Operating System Basic Linux Process Management (Linux进程管理) Cgroups Linux Namespaces Rootfs &amp;amp; Container Image Image Registry  Kubernetes architecture （Kubernetes 架构） #  Node #  Kubelet #   Runtime （容器运行时）  CRI (Container Runtime Interface) Runtime shims （容器运行时插件）  Cri-containerd （containerd） Dockershim （Docker） Cri-o （runC） Rktlet （rkt） Frakti （KataContainers）   RuntimeClass (新特性：容器运行时类)   Networking  CNI (Container Network Interface) Linux Network Namespace Network plugins （网络插件）  Flannel Calico OVS SR-IOV macvlan/ipvlan Opencontrail Weave Cilium （新插件，支持BPF，推荐）     Storage  CSI (Container Storage Interface) Persistent Volume &amp;amp; Persistent Volume Claim Volume plugins （存储插件，仅负责提供PV）  NFS Cinder GlusterFS Ceph Local path   Volume extenstion (存储扩展，负责提供完整的Storage方案)  Rook.</description>
    </item>
    
    <item>
      <title>技能图谱</title>
      <link>https://cctrip.github.io/notes/docs/technology/cloud/container/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/cloud/container/map/</guid>
      <description>技能图谱 #  容器化工具 #    Docker  LXC  RunC  Rkt  Systemd-nspawn  Garden  Vagga  VMWare Photon  gVisor  Pouch Container  Kata Containers  监控和数据收集 #    Sysdig Monitor  cAdvisor  Weave Scope  Prometheus  TICK-Stack  Docker-Alertd  Grafana  Cockpit  基础设施集成 #    Magnum  Boot2Docker  MaestroNG  CloudFoundry Containers Service Broker  编排和调度 #    Crane  Mesos  Marathon  Compose  Yarn  Kubernetes  Openshift Origin  Rancher  K3s  Nomad  SwarmKit  Nebula  Dokku  Flynn  商业平台 #    AWS Container Service  Google Container Engine  Azure Container Service  阿里云容器服务  腾讯云容器服务  华为云容器引擎  容器镜像仓库 #    Repository  Nexus  Habor  Portus  Dragonfly  服务发现和容器 #    Consul  Etcd  ZooKeeper  Eureka  Traefik  Registrator  容器日志收集处理 #    Splunk  Elastic Stack  Fluentd  Flume  Graylog  Rsyslog  容器相关的系统发行版 #    Container Linux (CoreOS)  Project Atomic  RancherOS  ClearLinux  VMWare Photon  Talos  k3os  LinuxKit  SmartOS  容器网络 #    Pipework  Flannel  Calico  Weave  Kubenet  Contiv  OpenContrail  MacVlan  Canal  Romana  Submariner  容器安全 #    Anchore Engine  Aqua Microscanner  Clair  Dagda  Twistlock  OpenSCAP  Notary  Twistlock  SELinux  AppArmor  容器数据持久化 #    Ceph  Convoy  REX-Ray  Netshare  OpenStorage  容器相关标准 #    OCI Runtime Spec  OCI Image Spec  OCI Distribution Spec  Container Network Interface  Container Storage Interface   </description>
    </item>
    
    <item>
      <title>数组</title>
      <link>https://cctrip.github.io/notes/docs/technology/leetcode/learn/array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/leetcode/learn/array/</guid>
      <description>数组 #  什么是数组？ #   An Array is a collection of items. The items could be integers, strings, DVDs, games, books—anything really. The items are stored in neighboring (contiguous) memory locations. Because they&amp;rsquo;re stored together, checking through the entire collection of items is straightforward.
  数组的CRUD #  创建和访问数组 #  //数组，长度不可变 //切片，长度可变 func arraySlice() { //创建数组(声明长度) 	var array1 = [5]int{1, 2, 3} //创建数组(不声明长度) 	var array2 = [.</description>
    </item>
    
    <item>
      <title>API文档</title>
      <link>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/api/doc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/api/doc/</guid>
      <description>API文档 #  API Conventions #  This document is oriented at users who want a deeper understanding of the Kubernetes API structure, and developers wanting to extend the Kubernetes API. An introduction to using resources with kubectl can be found in the object management overview.
Table of Contents
 Types (Kinds)   Resources Objects   Metadata Spec and Status   Typical status properties    References to related objects  Lists of named subobjects preferred over maps  Primitive types  Constants  Unions    Lists and Simple kinds    Differing Representations Verbs on Resources   PATCH operations    Idempotency  Optional vs.</description>
    </item>
    
    <item>
      <title>Calico</title>
      <link>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/network/calico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/network/calico/</guid>
      <description>Calico #  </description>
    </item>
    
    <item>
      <title>矛盾论</title>
      <link>https://cctrip.github.io/notes/docs/other/read/%E7%9F%9B%E7%9B%BE%E8%AE%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/other/read/%E7%9F%9B%E7%9B%BE%E8%AE%BA/</guid>
      <description>矛盾论 #  （一九三七年八月）
 这篇哲学论文，是毛泽东继《实践论》之后，为了同一的目的，即为了克服存在于中国共产党内的严重的教条主义思想而写的，曾在延安的抗日军事政治大学作过讲演。在收入本书第一版的时候，作者作了部分的补充、删节和修改。
 　事物的矛盾法则，即对立统一的法则，是唯物辩证法的最根本的法则。列宁说：“就本来的意义讲，辩证法是研究对象的本质自身中的矛盾。”⑴列宁常称这个法则为辩证法的本质，又称之为辩证法的核心⑵。因此，我们在研究这个法则时，不得不涉及广泛的方面，不得不涉及许多的哲学问题。如果我们将这些问题都弄清楚了，我们就在根本上懂得了唯物辩证法。这些问题是：两种宇宙观；矛盾的普遍性；矛盾的特殊性；主要的矛盾和主要的矛盾方面；矛盾诸方面的同一性和斗争性；对抗在矛盾中的地位。
苏联哲学界在最近数年中批判了德波林学派⑶的唯心论，这件事引起了我们的极大的兴趣。德波林的唯心论在中国共产党内发生了极坏的影响，我们党内的教条主义思想不能说和这个学派的作风没有关系。因此，我们现在的哲学研究工作，应当以扫除教条主义思想为主要的目标。
一　两种宇宙观 #  　在人类的认识史中，从来就有关于宇宙发展法则的两种见解，一种是形而上学的见解，一种是辩证法的见解，形成了互相对立的两种宇宙观。列宁说：“对于发展（进化）所持的两种基本的（或两种可能的？或两种在历史上常见的？）观点是：（一）认为发展是减少和增加，是重复；（二）认为发展是对立的统一（统一物分成为两个互相排斥的对立，而两个对立又互相关联着）。”⑷列宁说的就是这两种不同的宇宙观。
形而上学，亦称玄学。这种思想，无论在中国，在欧洲，在一个很长的历史时间内，是属于唯心论的宇宙观，并在人们的思想中占了统治的地位。在欧洲，资产阶级初期的唯物论，也是形而上学的。由于欧洲许多国家的社会经济情况进到了资本主义高度发展的阶段，生产力、阶级斗争和科学均发展到了历史上未有过的水平，工业无产阶级成为历史发展的最伟大的动力，因而产生了马克思主义的唯物辩证法的宇宙观。于是，在资产阶级那里，除了公开的极端露骨的反动的唯心论之外，还出现了庸俗的进化论，出来对抗唯物辩证法。
所谓形而上学的或庸俗进化论的宇宙观，就是用孤立的、静止的和片面的观点去看世界。这种宇宙观把世界一切事物，一切事物的形态和种类，都看成是永远彼此孤立和永远不变化的。如果说有变化，也只是数量的增减和场所的变更。而这种增减和变更的原因，不在事物的内部而在事物的外部，即是由于外力的推动。形而上学家认为，世界上各种不同事物和事物的特性，从它们一开始存在的时候就是如此。后来的变化，不过是数量上的扩大或缩小。他们认为一种事物永远只能反复地产生为同样的事物，而不能变化为另一种不同的事物。在形而上学家看来，资本主义的剥削，资本主义的竞争，资本主义社会的个人主义思想等，就是在古代的奴隶社会里，甚至在原始社会里，都可以找得出来，而且会要永远不变地存在下去。说到社会发展的原因，他们就用社会外部的地理、气候等条件去说明。他们简单地从事物外部去找发展的原因，否认唯物辩证法所主张的事物因内部矛盾引起发展的学说。因此，他们不能解释事物的质的多样性，不能解释一种质变为他种质的现象。这种思想，在欧洲，在十七世纪和十八世纪是机械唯物论，在十九世纪末和二十世纪初则有庸俗进化论。在中国，则有所谓“天不变，道亦不变”⑸的形而上学的思想，曾经长期地为腐朽了的封建统治阶级所拥护。近百年来输入了欧洲的机械唯物论和庸俗进化论，则为资产阶级所拥护。
和形而上学的宇宙观相反，唯物辩证法的宇宙观主张从事物的内部、从一事物对他事物的关系去研究事物的发展，即把事物的发展看做是事物内部的必然的自己的运动，而每一事物的运动都和它的周围其他事物互相联系着和互相影响着。事物发展的根本原因，不是在事物的外部而是在事物的内部，在于事物内部的矛盾性。任何事物内部都有这种矛盾性，因此引起了事物的运动和发展。事物内部的这种矛盾性是事物发展的根本原因，一事物和他事物的互相联系和互相影响则是事物发展的第二位的原因。这样，唯物辩证法就有力地反对了形而上学的机械唯物论和庸俗进化论的外因论或被动论。这是清楚的，单纯的外部原因只能引起事物的机械的运动，即范围的大小，数量的增减，不能说明事物何以有性质上的千差万别及其互相变化。事实上，即使是外力推动的机械运动，也要通过事物内部的矛盾性。植物和动物的单纯的增长，数量的发展，主要地也是由于内部矛盾所引起的。同样，社会的发展，主要地不是由于外因而是由于内因。许多国家在差不多一样的地理和气候的条件下，它们发展的差异性和不平衡性，非常之大。同一个国家吧，在地理和气候并没有变化的情形下，社会的变化却是很大的。帝国主义的俄国变为社会主义的苏联，封建的闭关锁国的日本变为帝国主义的日本，这些国家的地理和气候并没有变化。长期地被封建制度统治的中国，近百年来发生了很大的变化，现在正在变化到一个自由解放的新中国的方向去，中国的地理和气候并没有变化。整个地球及地球各部分的地理和气候也是变化着的，但以它们的变化和社会的变化相比较，则显得很微小，前者是以若干万年为单位而显现其变化的，后者则在几千年、几百年、几十年、甚至几年或几个月（在革命时期）内就显现其变化了。按照唯物辩证法的观点，自然界的变化，主要地是由于自然界内部矛盾的发展。社会的变化，主要地是由于社会内部矛盾的发展，即生产力和生产关系的矛盾，阶级之间的矛盾，新旧之间的矛盾，由于这些矛盾的发展，推动了社会的前进，推动了新旧社会的代谢。唯物辩证法是否排除外部的原因呢？并不排除。唯物辩证法认为外因是变化的条件，内因是变化的根据，外因通过内因而起作用。鸡蛋因得适当的温度而变化为鸡子，但温度不能使石头变为鸡子，因为二者的根据是不同的。各国人民之间的互相影响是时常存在的。在资本主义时代，特别是在帝国主义和无产阶级革命的时代，各国在政治上、经济上和文化上的互相影响和互相激动，是极其巨大的。十月社会主义革命不只是开创了俄国历史的新纪元，而且开创了世界历史的新纪元，影响到世界各国内部的变化，同样地而且还特别深刻地影响到中国内部的变化，但是这种变化是通过了各国内部和中国内部自己的规律性而起的。两军相争，一胜一败，所以胜败，皆决于内因。胜者或因其强，或因其指挥无误，败者或因其弱，或因其指挥失宜，外因通过内因而引起作用。一九二七年中国大资产阶级战败了无产阶级，是通过中国无产阶级内部的（中国共产党内部的）机会主义而起作用的。当着我们清算了这种机会主义的时候，中国革命就重新发展了。后来，中国革命又受了敌人的严重的打击，是因为我们党内产生了冒险主义。当着我们清算了这种冒险主义的时候，我们的事业就又重新发展了。由此看来，一个政党要引导革命到胜利，必须依靠自己政治路线的正确和组织上的巩固。
辩证法的宇宙观，不论在中国，在欧洲，在古代就产生了。但是古代的辩证法带着自发的朴素的性质，根据当时的社会历史条件，还不可能有完备的理论，因而不能完全解释宇宙，后来就被形而上学所代替。生活在十八世纪末和十九世纪初期的德国著名哲学家黑格尔，对于辩证法曾经给了很重要的贡献，但是他的辩证法却是唯心的辩证法。直到无产阶级运动的伟大的活动家马克思和恩格斯综合了人类认识史的积极的成果，特别是批判地吸取了黑格尔的辩证法的合理的部分，创造了辩证唯物论和历史唯物论这个伟大的理论，才在人类认识史上起了一个空前的大革命。后来，经过列宁和斯大林，又发展了这个伟大的理论。这个理论一经传到中国来，就在中国思想界引起了极大的变化。
这个辩证法的宇宙观，主要地就是教导人们要善于去观察和分析各种事物的矛盾的运动，并根据这种分析，指出解决矛盾的方法。因此，具体地了解事物矛盾这一个法则，对于我们是非常重要的。
二　矛盾的普遍性 #  　为了叙述的便利起见，我在这里先说矛盾的普遍性，再说矛盾的特殊性。这是因为马克思主义的伟大的创造者和继承者马克思、恩格斯、列宁、斯大林他们发现了唯物辩证法的宇宙观，已经把唯物辩证法应用在人类历史的分析和自然历史的分析的许多方面，应用在社会的变革和自然的变革（例如在苏联）的许多方面，获得了极其伟大的成功，矛盾的普遍性已经被很多人所承认，因此，关于这个问题只需要很少的话就可以说明白；而关于矛盾的特殊性的问题，则还有很多的同志，特别是教条主义者，弄不清楚。他们不了解矛盾的普遍性即寓于矛盾的特殊性之中。他们也不了解研究当前具体事物的矛盾的特殊性，对于我们指导革命实践的发展有何等重要的意义。因此，关于矛盾的特殊性的问题应当着重地加以研究，并用足够的篇幅加以说明。为了这个缘故，当着我们分析事物矛盾的法则的时候，我们就先来分析矛盾的普遍性的问题，然后再着重地分析矛盾的特殊性的问题，最后仍归到矛盾的普遍性的问题。
矛盾的普遍性或绝对性这个问题有两方面的意义。其一是说，矛盾存在于一切事物的发展过程中；其二是说，每一事物的发展过程中存在着自始至终的矛盾运动。
恩格斯说：“运动本身就是矛盾。”⑹列宁对于对立统一法则所下的定义，说它就是“承认（发现）自然界（精神和社会两者也在内）的一切现象和过程都含有互相矛盾、互相排斥、互相对立的趋向”⑺。这些意见是对的吗？是对的。一切事物中包含的矛盾方面的相互依赖和相互斗争，决定一切事物的生命，推动一切事物的发展。没有什么事物是不包含矛盾的，没有矛盾就没有世界。
矛盾是简单的运动形式（例如机械性的运动）的基础，更是复杂的运动形式的基础。
恩格斯这样说明过矛盾的普遍性：“如果简单的机械的移动本身包含着矛盾，那末，物质的更高的运动形式，特别是有机生命及其发展，就更加包含着矛盾。……生命首先就在于：生物在每一个瞬间是它自身，但却又是别的什么。所以，生命也是存在于物体和过程本身中的不断地自行产生并自行解决的矛盾；这一矛盾一停止，生命亦即停止，于是死就来到。同样，我们看到了，在思维的范围以内我们也不能避免矛盾，并且我们看到了，例如，人的内部无限的认识能力与此种认识能力仅在外部被局限的而且认识上也被局限的个别人们身上的实际的实现二者之间的矛盾，是在人类世代的无穷的——至少对于我们，实际上是无穷的——连续系列之中，是在无穷的前进运动之中解决的。”
“高等数学的主要基础之一，就是矛盾……”
“就是初等数学，也充满着矛盾。……”⑻
列宁也这样说明过矛盾的普遍性：“在数学中，正和负，微分和积分。
在力学中，作用和反作用。
在物理学中，阳电和阴电。
在化学中，原子的化合和分解。
在社会科学中，阶级斗争。”⑼
战争中的攻守，进退，胜败，都是矛盾着的现象。失去一方，他方就不存在。双方斗争而又联结，组成了战争的总体，推动了战争的发展，解决了战争的问题。
人的概念的每一差异，都应把它看作是客观矛盾的反映。客观矛盾反映入主观的思想，组成了概念的矛盾运动，推动了思想的发展，不断地解决了人们的思想问题。
党内不同思想的对立和斗争是经常发生的，这是社会的阶级矛盾和新旧事物的矛盾在党内的反映。党内如果没有矛盾和解决矛盾的思想斗争，党的生命也就停止了。
由此看来，不论是简单的运动形式，或复杂的运动形式，不论是客观现象，或思想现象，矛盾是普遍地存在着，矛盾存在于一切过程中，这一点已经弄清楚了。但是每一过程的开始阶段，是否也有矛盾存在呢？是否每一事物的发展过程具有自始至终的矛盾运动呢？
从苏联哲学界批判德波林学派的文章中看出，德波林学派有这样一种见解，他们认为矛盾不是一开始就在过程中出现，须待过程发展到一定的阶段才出现。那末，在那一时间以前，过程发展的原因不是由于内部的原因，而是由于外部的原因了。这样，德波林回到形而上学的外因论和机械论去了。拿这种见解去分析具体的问题，他们就看见在苏联条件下富农和一般农民之间只有差异，并无矛盾，完全同意了布哈林的意见。在分析法国革命时，他们就认为在革命前，工农资产阶级合组的第三等级中，也只有差异，并无矛盾。德波林学派这类见解是反马克思主义的。他们不知道世界上的每一差异中就已经包含着矛盾，差异就是矛盾。劳资之间，从两阶级发生的时候起，就是互相矛盾的，仅仅还没有激化而已。工农之间，即使在苏联的社会条件下，也有差异，它们的差异就是矛盾，仅仅不会激化成为对抗，不取阶级斗争的形态，不同于劳资间的矛盾；它们在社会主义建设中形成巩固的联盟，并在由社会主义走向共产主义的发展过程中逐渐地解决这个矛盾。这是矛盾的差别性的问题，不是矛盾的有无的问题。矛盾是普遍的、绝对的，存在于事物发展的一切过程中，又贯串于一切过程的始终。
新过程的发生是什么呢？这是旧的统一和组成此统一的对立成分让位于新的统一和组成此统一的对立成分，于是新过程就代替旧过程而发生。旧过程完结了，新过程发生了。新过程又包含着新矛盾，开始它自己的矛盾发展史。
事物发展过程的自始至终的矛盾运动，列宁指出马克思在《资本论》中模范地作了这样的分析。这是研究任何事物发展过程所必须应用的方法。列宁自己也正确地应用了它，贯彻于他的全部著作中。
“马克思在《资本论》中，首先分析的是资产阶级社会（商品社会）里最简单的、最普通的、最基本的、最常见的、最平常的、碰到亿万次的关系——商品交换。这一分析在这个最简单的现象之中（资产阶级社会的这个‘细胞’之中）暴露了现代社会的一切矛盾（以及一切矛盾的胚芽）。往后的叙述又向我们表明了这些矛盾和这个社会各个部分总和的自始至终的发展（增长与运动两者）。”
列宁说了上面的话之后，接着说道：“这应该是一般辩证法的……叙述（以及研究）方法。”⑽
中国共产党人必须学会这个方法，才能正确地分析中国革命的历史和现状，并推断革命的将来。
三　矛盾的特殊性 #  　矛盾存在于一切事物发展的过程中，矛盾贯串于每一事物发展过程的始终，这是矛盾的普遍性和绝对性，前面已经说过了。现在来说矛盾的特殊性和相对性。
这个问题，应从几种情形中去研究。
首先是各种物质运动形式中的矛盾，都带特殊性。人的认识物质，就是认识物质的运动形式，因为除了运动的物质以外，世界上什么也没有，而物质的运动则必取一定的形式。对于物质的每一种运动形式，必须注意它和其他各种运动形式的共同点。但是，尤其重要的，成为我们认识事物的基础的东西，则是必须注意它的特殊点，就是说，注意它和其他运动形式的质的区别。只有注意了这一点，才有可能区别事物。任何运动形式，其内部都包含着本身特殊的矛盾。这种特殊的矛盾，就构成一事物区别于他事物的特殊的本质。这就是世界上诸种事物所以有千差万别的内在的原因，或者叫做根据。自然界存在着许多的运动形式，机械运动、发声、发光、发热、电流、化分、化合等等都是。所有这些物质的运动形式，都是互相依存的，又是本质上互相区别的。每一物质的运动形式所具有的特殊的本质，为它自己的特殊的矛盾所规定。这种情形，不但在自然界中存在着，在社会现象和思想现象中也是同样地存在着。每一种社会形式和思想形式，都有它的特殊的矛盾和特殊的本质。
科学研究的区分，就是根据科学对象所具有的特殊的矛盾性。因此，对于某一现象的领域所特有的某一种矛盾的研究，就构成某一门科学的对象。例如，数学中的正数和负数，机械学中的作用和反作用，物理学中的阴电和阳电，化学中的化分和化合，社会科学中的生产力和生产关系、阶级和阶级的互相斗争，军事学中的攻击和防御，哲学中的唯心论和唯物论、形而上学观和辩证法观等等，都是因为具有特殊的矛盾和特殊的本质，才构成了不同的科学研究的对象。固然，如果不认识矛盾的普遍性，就无从发现事物运动发展的普遍的原因或普遍的根据；但是，如果不研究矛盾的特殊性，就无从确定一事物不同于他事物的特殊的本质，就无从发现事物运动发展的特殊的原因，或特殊的根据，也就无从辨别事物，无从区分科学研究的领域。
就人类认识运动的秩序说来，总是由认识个别的和特殊的事物，逐步地扩大到认识一般的事物。人们总是首先认识了许多不同事物的特殊的本质，然后才有可能更进一步地进行概括工作，认识诸种事物的共同的本质。当着人们已经认识了这种共同的本质以后，就以这种共同的认识为指导，继续地向着尚未研究过的或者尚未深入地研究过的各种具体的事物进行研究，找出其特殊的本质，这样才可以补充、丰富和发展这种共同的本质的认识，而使这种共同的本质的认识不致变成枯槁的和僵死的东西。这是两个认识的过程：一个是由特殊到一般，一个是由一般到特殊。人类的认识总是这样循环往复地进行的，而每一次的循环（只要是严格地按照科学的方法）都可能使人类的认识提高一步，使人类的认识不断地深化。我们的教条主义者在这个问题上的错误，就是，一方面，不懂得必须研究矛盾的特殊性，认识各别事物的特殊的本质，才有可能充分地认识矛盾的普遍性，充分地认识诸种事物的共同的本质；另一方面，不懂得在我们认识了事物的共同的本质以后，还必须继续研究那些尚未深入地研究过的或者新冒出来的具体的事物。我们的教条主义者是懒汉，他们拒绝对于具体事物做任何艰苦的研究工作，他们把一般真理看成是凭空出现的东西，把它变成为人们所不能够捉摸的纯粹抽象的公式，完全否认了并且颠倒了这个人类认识真理的正常秩序。他们也不懂得人类认识的两个过程的互相联结——由特殊到一般，又由一般到特殊，他们完全不懂得马克思主义的认识论。
不但要研究每一个大系统的物质运动形式的特殊的矛盾性及其所规定的本质，而且要研究每一个物质运动形式在其发展长途中的每一个过程的特殊的矛盾及其本质。一切运动形式的每一个实在的非臆造的发展过程内，都是不同质的。我们的研究工作必须着重这一点，而且必须从这一点开始。
不同质的矛盾，只有用不同质的方法才能解决。例如，无产阶级和资产阶级的矛盾，用社会主义革命的方法去解决；人民大众和封建制度的矛盾，用民主革命的方法去解决；殖民地和帝国主义的矛盾，用民族革命战争的方法去解决；在社会主义社会中工人阶级和农民阶级的矛盾，用农业集体化和农业机械化的方法去解决；共产党内的矛盾，用批评和自我批评的方法去解决；社会和自然的矛盾，用发展生产力的方法去解决。过程变化，旧过程和旧矛盾消灭，新过程和新矛盾发生，解决矛盾的方法也因之而不同。俄国的二月革命和十月革命所解决的矛盾及其所用以解决矛盾的方法是根本上不相同的。用不同的方法去解决不同的矛盾，这是马克思列宁主义者必须严格地遵守的一个原则。教条主义者不遵守这个原则，他们不了解诸种革命情况的区别，因而也不了解应当用不同的方法去解决不同的矛盾，而只是千篇一律地使用一种自以为不可改变的公式到处硬套，这就只能使革命遭受挫折，或者将本来做得好的事情弄得很坏。
为要暴露事物发展过程中的矛盾在其总体上、在其相互联结上的特殊性，就是说暴露事物发展过程的本质，就必须暴露过程中矛盾各方面的特殊性，否则暴露过程的本质成为不可能，这也是我们作研究工作时必须十分注意的。
一个大的事物，在其发展过程中，包含着许多的矛盾。例如，在中国资产阶级民主革命过程中，有中国社会各被压迫阶级和帝国主义的矛盾，有人民大众和封建制度的矛盾，有无产阶级和资产阶级的矛盾，有农民及城市小资产阶级和资产阶级的矛盾，有各个反动的统治集团之间的矛盾等等，情形是非常复杂的。这些矛盾，不但各各有其特殊性，不能一律看待，而且每一矛盾的两方面，又各各有其特点，也是不能一律看待的。我们从事中国革命的人，不但要在各个矛盾的总体上，即矛盾的相互联结上，了解其特殊性，而且只有从矛盾的各个方面着手研究，才有可能了解其总体。所谓了解矛盾的各个方面，就是了解它们每一方面各占何等特定的地位，各用何种具体形式和对方发生互相依存又互相矛盾的关系，在互相依存又互相矛盾中，以及依存破裂后，又各用何种具体的方法和对方作斗争。研究这些问题，是十分重要的事情。列宁说：马克思主义的最本质的东西，马克思主义的活的灵魂，就在于具体地分析具体的情况⑾。就是说的这个意思。我们的教条主义者违背列宁的指示，从来不用脑筋具体地分析任何事物，做起文章或演说来，总是空洞无物的八股调，在我们党内造成了一种极坏的作风。
研究问题，忌带主观性、片面性和表面性。所谓主观性，就是不知道客观地看问题，也就是不知道用唯物的观点去看问题。这一点，我在《实践论》一文中已经说过了。所谓片面性，就是不知道全面地看问题。例如：只了解中国一方、不了解日本一方，只了解共产党一方、不了解国民党一方，只了解无产阶级一方、不了解资产阶级一方，只了解农民一方、不了解地主一方，只了解顺利情形一方、不了解困难情形一方，只了解过去一方、不了解将来一方，只了解个体一方、不了解总体一方，只了解缺点一方、不了解成绩一方，只了解原告一方、不了解被告一方，只了解革命的秘密工作一方、不了解革命的公开工作一方，如此等等。一句话，不了解矛盾各方的特点。这就叫做片面地看问题。或者叫做只看见局部，不看见全体，只看见树木，不看见森林。这样，是不能找出解决矛盾的方法的，是不能完成革命任务的，是不能做好所任工作的，是不能正确地发展党内的思想斗争的。孙子论军事说：“知彼知己，百战不殆。”⑿他说的是作战的双方。唐朝人魏徵说过：“兼听则明，偏信则暗。”⒀也懂得片面性不对。可是我们的同志看问题，往往带片面性，这样的人就往往碰钉子。《水浒传》上宋江三打祝家庄⒁，两次都因情况不明，方法不对，打了败仗。后来改变方法，从调查情形入手，于是熟悉了盘陀路，拆散了李家庄、扈家庄和祝家庄的联盟，并且布置了藏在敌人营盘里的伏兵，用了和外国故事中所说木马计⒂相像的方法，第三次就打了胜仗。《水浒传》上有很多唯物辩证法的事例，这个三打祝家庄，算是最好的一个。列宁说：“要真正地认识对象，就必须把握和研究它的一切方面、一切联系和‘媒介’。我们决不会完全地作到这一点，可是要求全面性，将使我们防止错误，防止僵化。”⒃我们应该记得他的话。表面性，是对矛盾总体和矛盾各方的特点都不去看，否认深入事物里面精细地研究矛盾特点的必要，仅仅站在那里远远地望一望，粗枝大叶地看到一点矛盾的形相，就想动手去解决矛盾（答复问题、解决纠纷、处理工作、指挥战争）。这样的做法，没有不出乱子的。中国的教条主义和经验主义的同志们所以犯错误，就是因为他们看事物的方法是主观的、片面的和表面的。片面性、表面性也是主观性，因为一切客观事物本来是互相联系的和具有内部规律的，人们不去如实地反映这些情况，而只是片面地或表面地去看它们，不认识事物的互相联系，不认识事物的内部规律，所以这种方法是主观主义的。
不但事物发展的全过程中的矛盾运动，在其相互联结上，在其各方情况上，我们必须注意其特点，而且在过程发展的各个阶段中，也有其特点，也必须注意。
事物发展过程的根本矛盾及为此根本矛盾所规定的过程的本质，非到过程完结之日，是不会消灭的；但是事物发展的长过程中的各个发展的阶段，情形又往往互相区别。这是因为事物发展过程的根本矛盾的性质和过程的本质虽然没有变化，但是根本矛盾在长过程中的各个发展阶段上采取了逐渐激化的形式。并且，被根本矛盾所规定或影响的许多大小矛盾中，有些是激化了，有些是暂时地或局部地解决了，或者缓和了，又有些是发生了，因此，过程就显出阶段性来。如果人们不去注意事物发展过程中的阶段性，人们就不能适当地处理事物的矛盾。
例如，自由竞争时代的资本主义发展为帝国主义，这时，无产阶级和资产阶级这两个根本矛盾着的阶级的性质和这个社会的资本主义的本质，并没有变化；但是，两阶级的矛盾激化了，独占资本和自由资本之间的矛盾发生了，宗主国和殖民地的矛盾激化了，各资本主义国家间的矛盾即由各国发展不平衡的状态而引起的矛盾特别尖锐地表现出来了，因此形成了资本主义的特殊阶段，形成了帝国主义阶段。列宁主义之所以成为帝国主义和无产阶级革命时代的马克思主义，就是因为列宁和斯大林正确地说明了这些矛盾，并正确地作出了解决这些矛盾的无产阶级革命的理论和策略。
拿从辛亥革命⒄开始的中国资产阶级民主革命过程的情形来看，也有了若干特殊阶段。特别是在资产阶级领导时期的革命和在无产阶级领导时期的革命，区别为两个很大不同的历史阶段。这就是：由于无产阶级的领导，根本地改变了革命的面貌，引出了阶级关系的新调度，农民革命的大发动，反帝国主义和反封建主义的革命彻底性，由民主革命转变到社会主义革命的可能性，等等。所有这些，都是在资产阶级领导革命时期不可能出现的。虽然整个过程中根本矛盾的性质，过程之反帝反封建的民主革命的性质（其反面是半殖民地半封建的性质），并没有变化，但是，在这长时间中，经过了辛亥革命失败和北洋军阀统治，第一次民族统一战线的建立和一九二四年至一九二七年的革命，统一战线破裂和资产阶级转入反革命，新的军阀战争，土地革命战争，第二次民族统一战线建立和抗日战争等等大事变，二十多年间经过了几个发展阶段。在这些阶段中，包含着有些矛盾激化了（例如土地革命战争和日本侵入东北四省⒅），有些矛盾部分地或暂时地解决了（例如北洋军阀的被消灭，我们没收了地主的土地），有些矛盾重新发生了（例如新军阀之间的斗争，南方各革命根据地丧失后地主又重新收回土地）等等特殊的情形。
研究事物发展过程中的各个发展阶段上的矛盾的特殊性，不但必须在其联结上、在其总体上去看，而且必须从各个阶段中矛盾的各个方面去看。
例如国共两党。国民党方面，在第一次统一战线时期，因为它实行了孙中山的联俄、联共、援助工农的三大政策，所以它是革命的、有朝气的，它是各阶级的民主革命的联盟。一九二七年以后，国民党变到了与此相反的方面，成了地主和大资产阶级的反动集团。一九三六年十二月西安事变⒆后又开始向停止内战、联合共产党共同反对日本帝国主义这个方面转变。这就是国民党在三个阶段上的特点。形成这些特点，当然有种种的原因。中国共产党方面，在第一次统一战线时期，它是幼年的党，它英勇地领导了一九二四年至一九二七年的革命；但在对于革命的性质、任务和方法的认识方面，却表现了它的幼年性，因此在这次革命的后期所发生的陈独秀主义⒇能够起作用，使这次革命遭受了失败。一九二七年以后，它又英勇地领导了土地革命战争，创立了革命的军队和革命的根据地，但是它也犯过冒险主义的错误，使军队和根据地都受了很大的损失。一九三五年以后，它又纠正了冒险主义的错误，领导了新的抗日的统一战线，这个伟大的斗争现在正在发展。在这个阶段上，共产党是一个经过了两次革命的考验、有了丰富的经验的党。这些就是中国共产党在三个阶段上的特点。形成这些特点也有种种的原因。不研究这些特点，就不能了解两党在各个发展阶段上的特殊的相互关系：统一战线的建立，统一战线的破裂，再一个统一战线的建立。而要研究两党的种种特点，更根本的就必须研究这两党的阶级基础以及因此在各个时期所形成的它们和其他方面的矛盾的对立。例如，国民党在它第一次联合共产党的时期，一方面有和国外帝国主义的矛盾，因而它反对帝国主义；另一方面有和国内人民大众的矛盾，它在口头上虽然允许给予劳动人民以许多的利益，但在实际上则只给予很少的利益，或者简直什么也不给。在它进行反共战争的时期，则和帝国主义、封建主义合作反对人民大众，一笔勾销了人民大众原来在革命中所争得的一切利益，激化了它和人民大众的矛盾。现在抗日时期，国民党和日本帝国主义有矛盾，它一面要联合共产党，同时它对共产党和国内人民并不放松其斗争和压迫。共产党则无论在哪一时期，均和人民大众站在一道，反对帝国主义和封建主义；但在现在的抗日时期，由于国民党表示抗日，它对国民党和国内封建势力，也就采取了缓和的政策。由于这些情况，所以或者造成了两党的联合，或者造成了两党的斗争，而且即使在两党联合的时期也有又联合又斗争的复杂的情况。如果我们不去研究这些矛盾方面的特点，我们就不但不能了解这两个党各各和其他方面的关系，也不能了解两党之间的相互关系。
由此看来，不论研究何种矛盾的特性——各个物质运动形式的矛盾，各个运动形式在各个发展过程中的矛盾，各个发展过程的矛盾的各方面，各个发展过程在其各个发展阶段上的矛盾以及各个发展阶段上的矛盾的各方面，研究所有这些矛盾的特性，都不能带主观随意性，必须对它们实行具体的分析。离开具体的分析，就不能认识任何矛盾的特性。我们必须时刻记得列宁的话：对于具体的事物作具体的分析。</description>
    </item>
    
    <item>
      <title>配置</title>
      <link>https://cctrip.github.io/notes/docs/technology/system/application/nginx/config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/system/application/nginx/config/</guid>
      <description>配置 #  user www-data; worker_processes auto; worker_rlimit_nofile 650000; pid /run/nginx.pid; events { worker_connections 76800; # multi_accept on; } http { sendfile on; tcp_nopush on; tcp_nodelay on; #keepalive_timeout 1000;  keepalive_timeout 120s 120s; keepalive_requests 1500; types_hash_max_size 2048; server_tokens off; #define request limit zone  limit_req_zone $limit zone=req_limit:1024m rate=30r/s ; limit_req_zone $limit zone=auth_limit:1024m rate=10r/s ; limit_req_status 466; #limit_req_zone $binary_remote_addr zone=testreq:800m rate=1r/s;  #define connection limit zone per ip  limit_conn_zone $limit zone=conn_limit:100m; # Gzip Settings  ##  gzip on; gzip_http_version 1.</description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://cctrip.github.io/notes/docs/technology/leetcode/learn/linklist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/leetcode/learn/linklist/</guid>
      <description>链表 #  单向链表 #   Each node in a singly-linked list contains not only the value but also a reference field to link to the next node. By this way, the singly-linked list organizes all the nodes in a sequence.
  CRUD #  创建一个单向链表 #  type List struct { Value {}interface Next *List } import &amp;#34;container/list&amp;#34; func list() { l := list.New() }  添加元素 #  func Append() { }  删除元素 #  func Remove() { } </description>
    </item>
    
    <item>
      <title>Cilium</title>
      <link>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/network/cilium/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/network/cilium/</guid>
      <description>Cilium #  </description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://cctrip.github.io/notes/docs/technology/leetcode/learn/bintree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/leetcode/learn/bintree/</guid>
      <description>二叉树 #   树是模拟分层树结构的常用数据结构。
树的每个节点将具有一个根值和对其他称为子节点的节点的引用列表。从图的角度看，树也可以定义为有向无环图，它具有N个节点和N-1个边。
二叉树是最典型的树结构之一。顾名思义，二叉树是一种树数据结构，其中每个节点最多具有两个子节点，分别称为左子节点和右子节点。
  遍历 #  前序遍历 #  根结点 &amp;mdash;&amp;gt; 左子树 &amp;mdash;&amp;gt; 右子树
中序遍历 #  左子树&amp;mdash;&amp;gt; 根结点 &amp;mdash;&amp;gt; 右子树
后序遍历 #  左子树 &amp;mdash;&amp;gt; 右子树 &amp;mdash;&amp;gt; 根结点
层次遍历 #  广度优先 #  深度优先 #  </description>
    </item>
    
    <item>
      <title>AWS VPC CNI</title>
      <link>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/network/aws/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/cloud/container/kubernetes/network/aws/</guid>
      <description>AWS VPC CNI #  Goal #  K8S网络需求 #   Pod之间的通信不需要通过NAT转换 Node和Pod通信不需要通过NAT转换 Pod所看到的IP地址与其他人所看到的IP地址相同   K8S运行在AWS VPC上的目标 #   Pod联网必须支持与用户从EC2联网中获得的特性相当的高吞吐量和可用性，低延迟和最小抖动 可以使用跟EC2一样的网络安全组 网络操作必须简单安全。用户必须能够应用现有的AWS VPC网络和安全最佳实践，以通过AWS VPC构建Kubernetes集群 只需几秒钟即可设置Pod网络 管理员应能够将群集扩展到2000个节点   方案 #   为每个Node(ec2)创建多个弹性网络接口(ENIs)，并分配secondary IP 对于每个Pod，选择一个可用的secondary IP，将其分配给Pod，并实现以下功能：  在单个主机上进行Pod到Pod的通信 在不同主机上进行Pod到Pod的通信 允许在Pod和AWS服务进行通信 允许Pod和本地数据中心进行通信 允许Pod和Internet进行通信     在EC2-VPC里，每个实例可以创建多个ENI，每个ENI可以分配多个IP地址。 任何发往这些IP地址之一的数据包，EC2-VPC都会将该数据包传递到实例。
ENI是虚拟网络接口，您可以将其附加到VPC中的实例。 将ENI附加到实例后，将创建一个对应的接口。 主ENI IP地址会自动分配给该接口。 所有辅助地址均未分配，并且由主机所有者决定如何配置它们。
  架构 #  Pod To Pod #    Inside a Pod #  IP address</description>
    </item>
    
    <item>
      <title>100个问题</title>
      <link>https://cctrip.github.io/notes/docs/technology/other/interview/100/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/other/interview/100/</guid>
      <description>100个问题 #  1. What is a skill you have that most people don’t acknowledge?
​	优势：网络知识，TCP，路由
2. How would your best friend describe you?
​	脾气好，头脑灵活
3. What is the first complex problem you can remember solving as a kid?
​	暂无
4. What’s your least favorite time of day and why?
​	暂无
5. Do you work better as an individual or as part of a team?
​	个人</description>
    </item>
    
    <item>
      <title>Prometheus</title>
      <link>https://cctrip.github.io/notes/docs/technology/cloud/devops/monitor/prometheus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/cloud/devops/monitor/prometheus/</guid>
      <description>Prometheus #    AlertManager #  webhook #  doraemon #   Prometheus #   Discovery #  consul #  registrtor #  exporter #   UI #  Grafana #   K8s-Operator #  </description>
    </item>
    
    <item>
      <title>目标</title>
      <link>https://cctrip.github.io/notes/docs/technology/other/interview/request/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/other/interview/request/</guid>
      <description>目标 #  Ali #    阿里云智能事业群-监控运维平台技术专家-杭州/北京  #运维方向 运维方向：百万服务器运维管理规模的技术挑战，衔接监控与安全平台能力，为客户提供资源授权、可靠变更以及运维产品和解决方案 岗位要求： 全岗位通用要求 1. 对创新有发自内心的热爱和激情，学习能力强，认真负责，有团队合作精神并乐于分享 2. 熟悉互联网应用架构，云计算，具备互联网架构设计经验，应用软件研发/运维工作背景 3. 善于总结和思考，正视技术挑战、有技术愿景，期望从事对业界有影响力的工作 运维方向：熟悉DevOps/PEOps以及运维、AIOps平台研发经验优先 岗位关键词 1. 通用要求：Java | Go 3. 运维方向：Kubernetes | K8S | Cloud Native | ServerLess | ServiceMesh | SRE | DevOps   蚂蚁金服-容器调度SRE  岗位描述： 全方面参与云原生的资源调度系统的设计，开发，优化与维护。蚂蚁金服在线和实时业务的容器调度，调度节点单集群规模超过万台服务器，为蚂蚁上层业务提供设施标准容器服务和全局资源动态分配调度。具体职责包括但不限于： 1. 设计调度系统高可用体系，用以保障双十一等大型活动的平稳进行 2. 标准化调度系统监控，日志采集，包括SLA的制定与故障定位 3. 建立统一额度管控，弹性伸缩调度，提升系统资源利用率 4. 建设自动化及工程化的解决方式，以减少在传统运维层面的人力投入，做到无人值守。 岗位要求： 1. 至少精通一门编程语言，有软件开发背景，Java/Golang优先 2. 熟悉Linux系统和 Shell，对网络及基础设施层有一定的了解和知识储备 3. 有Docker、k8s 、微服务治理及资源调度经验者优先 4. 熟悉监控及自动化部署平台研发，具有大规模集群调度和架构设计经验优先 5. 有良好的沟通，团队协作能力 6. 熟悉DevOps流程，理解传统运维痛点   蚂蚁集团-云原生基础设施 SRE  二、中间件 SRE 蚂蚁金服中间件团队使用 Service Mesh、SofaStack、Serverless 等技术，上层业务提供统一高效的服务注册、消息、定时任务、限流等能力。中间件SRE团队致力于打造新一代中间件云原生系统的SLA体系，建设各种场景下的高可用能力，推进新的云原生技术在蚂蚁快速落地的同时，为上游业务提供5个9的可用率。加入我们，你将 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/bigdata/application/kafka/architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/bigdata/application/kafka/architecture/</guid>
      <description>kafka架构 #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/bigdata/application/kafka/deploy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/bigdata/application/kafka/deploy/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/bigdata/application/kafka/optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/bigdata/application/kafka/optimization/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/bigdata/application/zookeeper/architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/bigdata/application/zookeeper/architecture/</guid>
      <description>Zookeeper架构 #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/bigdata/application/zookeeper/deploy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/bigdata/application/zookeeper/deploy/</guid>
      <description>Zookeeper部署 #  单机环境搭建 #    下载安装包
 wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz tar -zxvf zookeeper-3.4.10.tar.gz mv zookeeper-3.4.10 zookeeper    修改配置文件
 #vim zookeeper/conf/zoo.cfg tickTime=2000 initLimit=5 syncLimit=2 dataDir=/cache1/zookeeper/data #数据目录 clientPort=2181 #服务端口    配置日志保存目录
 #修改zookeeper/conf/log4j.properties文件 zookeeper.root.logger=INFO, ROLLINGFILE zookeeper.log.dir=/cache1/zookeeper/logs zookeeper.log.file=zookeeper.log #修改zookeeper/bin/zkEnv.sh if [ &amp;quot;x${ZOO_LOG_DIR}&amp;quot; = &amp;quot;x&amp;quot; ] then ZOO_LOG_DIR=&amp;quot;/cache1/zookeeper/logs/&amp;quot; fi if [ &amp;quot;x${ZOO_LOG4J_PROP}&amp;quot; = &amp;quot;x&amp;quot; ] then ZOO_LOG4J_PROP=&amp;quot;INFO,ROLLINGFILE&amp;quot; fi    启动服务
 cd zookeeper/bin &amp;amp;&amp;amp; ./zkServer.sh start     集群环境搭建 #    机器准备</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/bigdata/application/zookeeper/optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/bigdata/application/zookeeper/optimization/</guid>
      <description>Zookeeper优化 #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/cloud/devops/elk/elkinstall/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/cloud/devops/elk/elkinstall/</guid>
      <description>ELK安装 #  环境准备 #    CentOS 7
  Java 8
   ELK安装 #    配置ELK的repo文件
rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch #vim /etc/yum.repo.d/elk.repo [elasticsearch-6.x] name=Elasticsearch repository for 6.x packages baseurl=https://artifacts.elastic.co/packages/6.x/yum gpgcheck=1 gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch enabled=1 autorefresh=1 type=rpm-md    ElasticSearch
#install yum install elasticsearch /bin/systemctl daemon-reload /bin/systemctl enable elasticsearch.service systemctl start elasticsearch.service #Test curl http://localhost:9200/    Kibana
#install yum install kibana /bin/systemctl daemon-reload /bin/systemctl enable kibana.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/database/sql/mysql/cluster/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/database/sql/mysql/cluster/</guid>
      <description>MySQL Cluster #  Master-Slave #  Master配置 #  /etc/my.cnf 增加配置
[mysqld] server-id=1 log-bin=/cache1/mysql/log/mysql-bin.log #忽略系统库 binlog-ignore-db=mysql binlog-ignore-db=information_schema binlog-ignore-db=performance_schema  Replication 帐号创建
mysql&amp;gt; GRANT REPLICATION SLAVE ON *.* TO &#39;repl&#39;@&#39;%&#39; IDENTIFIED BY &#39;slave@2017&#39;;  导出数据到从库
mysql&amp;gt; USE newdatabase; mysql&amp;gt; FLUSH TABLES WITH READ LOCK; mysql&amp;gt; SHOW MASTER STATUS; +------------------+----------+--------------+---------------------------------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+---------------------------------------------+-------------------+ | mysql-bin.000002 | 754 | | mysql,information_schema,performance_schema | | +------------------+----------+--------------+---------------------------------------------+-------------------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/database/sql/mysql/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/database/sql/mysql/install/</guid>
      <description>Mysql 安装 #  源码编译安装 #  准备 #    CMake(build framework)
yum -y install cmake    GNU make(make program)
yum -y install make    GCC(ANSI C++ complier)
yum -y install gcc gcc-c++    Boost C++ libraries
  ncurses library
yum -y install ncurses ncurses-devel    Perl(run test scripts)
yum -y install perl     安装 #    创建用户组</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/hidden/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/hidden/</guid>
      <description>This page is hidden in menu #  Quondam non pater est dignior ille Eurotas #  Latent te facies #  Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.
 Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona #  O fallor in sustinui iussorum equidem.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/other/book_notes/codecademy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/other/book_notes/codecademy/</guid>
      <description>codecademy在线学习 #  HTML和CSS学习 #  HTML #  html基本机构 #  &amp;lt;!DOCTYPE html&amp;gt; //向浏览器声明类型 &amp;lt;html&amp;gt; //所有的html代码都要包含在该元素内 &amp;lt;head&amp;gt; //关于网页的信息，如标题 &amp;lt;title&amp;gt;First Web Page&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; //可见的html代码内容都放在该元素内 &amp;lt;p&amp;gt;Hello,World!&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  可见内容 #    标题
heading
 &amp;lt;h1&amp;gt;head&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt; &amp;lt;h3&amp;gt; &amp;lt;h4&amp;gt; &amp;lt;h5&amp;gt; &amp;lt;h6&amp;gt;    段落
paragraph
 &amp;lt;p&amp;gt;content&amp;lt;/p&amp;gt;    无序列表
unodered list, list item
 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;sub&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt;    有序列表
ordered list, list item</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/other/book_notes/CS50/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/other/book_notes/CS50/</guid>
      <description>CS50学习笔记 #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/other/book_notes/finacial/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/other/book_notes/finacial/</guid>
      <description>Finanical #  Goal Setting #  Understand How Goals Are Used #    What is a goal?
  Long term vs Intermediate vs Short term
  Is a financial goal any different than other goals?
  SMART Goals #    Specific
  Measurable
  Attainable
  Realistic
  Time
  Finanical Goals #    Saving</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/other/book_notes/thinkOS/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/other/book_notes/thinkOS/</guid>
      <description>操作系统思考 #  编译 #   编译语言和解释语言    编译语言
程序被翻译成机器语言，之后由硬件执行。
  解释语言
程序被软件解释器读取并执行。
  静态类型和动态类型    动态类型
无需定义变量类型，直到运行时才直到变量类型，解释语言通常支持动态类型。
  静态类型
需定义变量类型，编译语言通常限制为静态类型。
优点：
  编译时检查，可以更快找到错误。
  节省空间
动态语言，变量的名称在程序运行时存储在内存中，并且它们通常可由程序访问。 编译语言，变量的名称只存在编译时，而不是运行时。 编译器为每个变量选择一个位置，并记录这些位置作为所编译程序的一部分。变量的位置被称为“地址”。在运行期间，每个变量的值都存储在它的地址处，但变量的名称完全不会存储。      编译过程    预处理
C是包含&amp;quot;预处理指令&amp;quot;的几种语言之一，它生效于编译之前。例如，#include 指令使其他文件的源代码插入到指令所在的位置
  解析
编译器读取源代码，并构建程序的内部表示，称为&amp;quot;抽象语法树(AST)&amp;quot;。这一阶段的错误检查通常为语法错误。
  静态检查
编译器会检查变量和值得类型是否正确，函数调用是否带有正确数量和类型的参数，以及其他。这一阶段的错误检测通常为一些&amp;quot;静态语义&amp;quot;的错误
  代码生成
编译器读取程序的内部表示，并生成机器码或字节码
  链接
如果程序使用了定义在库中的值或函数，编译器需要找到合适的库并包含所需要的代码。
  优化</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/other/interview/classic/browser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/other/interview/classic/browser/</guid>
      <description>经典问题 #  1. 当输入google.com时，发生了什么？ #  1.1 URL解析 #  当输入的URL不合法时，浏览器会将输入的字符传给默认搜索引擎，
浏览器通过URL能知道以下信息：
protocol: http host: google.com resource: / 1.2 HTST #  1、浏览器检查自身的HTST列表，确认是否包含该主机。 2、若HTST存在该主机，使用https代替http，否则使用http。 1.3 DNS解析 #  1、浏览器检查自身的DNS缓存 2、查找本地hosts文件 3、发起DNS解析查询 4、查询 本地|ISP DNS服务器 5、本地|ISP DNS服务器像高层服务器发起递归查询直到查到该域名的解析IP 1.4 TCP连接建立 #  1、client端发送SYN请求到server端，声明自己的ISN为aaa (CLOSED--&amp;gt;SYN-SENT) 2、server端接收SYN包，声明自己的ISN为bbb，ACK信息为aaa+1，返回给client端 (LISTEN--&amp;gt;SYN-RECEIVED) 3、client端返回ACK为bbb+1为server端 (SYN-SENT--&amp;gt;ESTABLISHED) 4、数据交互 1.5 TLS连接建立 #  1.6 HTTP #   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/other/interview/history/interview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/other/interview/history/interview/</guid>
      <description>面试经历 #  CF #   如何部署 如何监控 部署怎么实现 docker的优势和劣势   RC #  一面 #  1、Docker部署
2、nginx_lua的几个阶段
3、TCP窗口滑动、慢启动
4、LVS的几种模式实现原理
5、nginx location的优先级
6、监控系统架构
7、网络7层的功能
8、HTTP的同源策略
9、算法题，开根号
10、python题，[for i range xxx] 与 (for i range xxx)区别
二面 #  1、浏览器输入网址后发生了什么？(客户端，服务端(框架里面的路由实现))
2、k8s ci/cd 迁移怎么做的
3、算法题，全排列
4、自动化做了什么
5、ansible做了什么
6、Docker如何实现隔离，属于什么级别的隔离
7、成本控制怎么做
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/other/interview/tech/technology/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/other/interview/tech/technology/</guid>
      <description>技术知识点 #  1. 计算机基础 #   硬件 #  1. 机器型号 #  dmidecode | awk -F&amp;#39;:&amp;#39; &amp;#39;/Product Name/{print $2}&amp;#39; 2. CPU信息 #  #获取逻辑CPU数 awk -F&#39;:&#39; &#39;/name/{print $2}&#39; /proc/cpuinfo | wc -l #获取CPU型号 awk -F&#39;:&#39; &#39;/name/{print $2}&#39; /proc/cpuinfo | uniq #获取物理cpu数 grep &amp;quot;physical id&amp;quot; /proc/cpuinfo | sort | uniq | wc -l 3. 内存信息 #  #获取内存大小 free -h #内存物理信息 dmidecode -t memory 4. 磁盘信息 #   5.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/other/myconfig/vim/vimconf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/other/myconfig/vim/vimconf/</guid>
      <description>Vim配置指南 #  Don&amp;rsquo;t put any lines in your vimrc that you don&amp;rsquo;t understand. #      Colors
   Spaces And Tabs
   UI Config
   Searching
   Folding
   Custom Movements
   Custom Leader
   CtrlP Settings
   Launch Config
   Tmux Config
   Autogroups
   Backups</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/other/solution/aboutNtpdate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/other/solution/aboutNtpdate/</guid>
      <description>时间同步相关问题 #  ntpdate:no server suitable for synchronization found #  Question： #  　在使用ntpdate同步时间时，出现了no server suitable for synchronization found的报错。
　通过ntpdate -d s2m.time.edu.cn 使用debug模式没有出现异常。
Answer： #  解决办法是，使用ntpdate -ubv s2m.time.edu.cn，可以正常同步了。
主要是-u选项的作用
-u：Direct ntpdate to use an unprivileged port for outgoing packets. This is most useful when behind a firewall that blocks incoming traffic to privileged ports, and you want to synchronize with hosts beyond the firewall. Note that the -d option always uses unprivileged ports.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/other/solution/aboutSsh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/other/solution/aboutSsh/</guid>
      <description>ssh连接相关问题 #  pam_tally2(sshd:auth): user root (0) has time limit [3s left] since last failure 日志 #  Question： #  工作中，碰到某服务器在批量ssh登陆操作时，出现大量的无法连接的情况。
Thinking： #  查看ssh日志(/var/log/secure)， 首先注意到的是，&amp;ldquo;Failed password for root from xxx.xxx.xxx.xxx port 51230 ssh2&amp;quot;错误，但发现密码并没有错误，并且只在批量操作时才会出现，故初步判断为连接数问题。
查看ssh连接数限制
/usr/sbin/sshd -T | grep -i max  调整参数，更改配置文件/etc/sshd/sshd_config
maxsessions 1000  重启服务后，依然没有效果。
再次查看日志，发现在做批量操作时，有大量的&amp;quot;pam_tally2(sshd:auth): user root (0) has time limit [3s left] since last failure&amp;quot;日志。
应该是pam模块做了相应的限制
查看配置文件 /etc/pam.d/sshd 文件
auth required pam_tally2.so deny=10 lock_time=3 unlock_time=30 even_deny_root root_unlock_time=30  Answer： #  更改配置文件：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/advanced/design/factoryMethod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/advanced/design/factoryMethod/</guid>
      <description>工厂方法模式(Factory Method Pattern) #  模式定义 #  工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。
 模式结构 #    Product：抽象产品
  ConcreteProduct：具体产品
  Factory：抽象工厂
  ConcreteFactory：具体工厂
   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/advanced/design/simpleFactory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/advanced/design/simpleFactory/</guid>
      <description>简单工厂模式(Simple Factory Pattern) #  模式定义 #  简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
 模式结构 #    Factory：工厂角色
工厂角色负责实现创建所有实例的内部逻辑
  Product：抽象产品角色
抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
  ConcreteProduct：具体产品角色
具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/language/python/CookBook/DataStructuresAndAlgorithms/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/language/python/CookBook/DataStructuresAndAlgorithms/README/</guid>
      <description>数据结构和算法 #    解压序列赋值给多个变量
问题，现在有一个包含N个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给N个变量？
实现： 详细代码
 &amp;gt;&amp;gt;&amp;gt; data = [&#39;John&#39;,170,60,(1999,9,9)] &amp;gt;&amp;gt;&amp;gt; name, height, weight, birthday = data ### 另一种方式 &amp;gt;&amp;gt;&amp;gt; name, height, weight, (year, mon, day) = data    解压可迭代对象赋值给多个变量
问题，如果一个可迭代对象的元素个数超过变量个数时，会抛出一个ValueError。那么怎样才能从这个可迭代对象中解压出N个元素出来？
实现： 详细代码
 &amp;gt;&amp;gt;&amp;gt; record = (&#39;Dave&#39;, &#39;dave@example.com&#39;, &#39;773-555-1212&#39;, &#39;847-555-1212&#39;) &amp;gt;&amp;gt;&amp;gt; name, email, *phone_numbers = record    保留最后N个元素
问题，在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？
实现： 详细代码
 &amp;gt;&amp;gt;&amp;gt; from collections import deque &amp;gt;&amp;gt;&amp;gt; q = deque(maxlen = 3) &amp;gt;&amp;gt;&amp;gt; q.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/language/python/CookBook/StringsAndText/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/language/python/CookBook/StringsAndText/README/</guid>
      <description>#字符串和文本
   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/language/python/Framework/Django/django/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/language/python/Framework/Django/django/</guid>
      <description>Django #  环境初始化 #  python3 install virtualenv cd demosite mkdir py3env virtualenv ./py3env/ source py3env/bin/activate #install Django pip3 install Django  项目初始化 #  django-admin startproject demosite python manage.py runserver python manage.py startapp polls  项目结构 #  demosite/ manage.py demosite/ __init__.py settings.py urls.py wsgi.py polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/language/python/Framework/Flask/flask/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/language/python/Framework/Flask/flask/</guid>
      <description>Flask #  安装 #  pip install flask   程序基本结构 #   初始化  所有 Flask 程序都必须创建一个程序实例。Web 服务器使用一种名为 Web 服务器网关接口（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这个对象处理。
from flask import Flask app = Flask(&#39;__name__&#39;)  路由和函数  程序实例需要知道对每个URL请求运行哪些代码，所以保存了一个URL到Python函数的映射关系。处理URL和函数之间关系的程序称为路由。 在Flask程序中定义路由的最简便方式，是使用程序实例提供的app.route修饰器，把修饰的函数注册为路由。
@app.route(&#39;/&#39;) def index(): return &#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&#39;   启动服务
if name == &amp;lsquo;main&amp;rsquo; app.run(Debug=True)
   模版 #  模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为渲染。为了渲染模板，Flask 使用了一个名为 Jinja2 的强大模板引擎。
Jinja2模板引擎 #  templates/user.html：Jinja2 模板
&amp;lt;h1&amp;gt;Hello {{ name }} !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/program/language/python/Framework/Scrapy/scrapy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/program/language/python/Framework/Scrapy/scrapy/</guid>
      <description>#Scrapy Scrapy是一个快速的高级Web爬网和Web抓取框架，用于抓取网站并从其页面提取结构化数据。
安装 #  pip install scrapy scrapy startproject scrapytest   第一个爬虫 #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/system/linux/guideBook/fileOperation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/system/linux/guideBook/fileOperation/</guid>
      <description>一切皆文件 #    列出文件列表
 ls [option] /PATH #不指定路径，默认为当前路径 option -l:长格式 文件类型: -:普通文件 d:目录文件 b:块设备文件（block） c：字符设备文件（character） l：符号链接文件（symbolic link file） p：命令管道（pipe） s：套接字文件（socket） 文件权限：9位，每三位一组(u-g-o),每一组：rwx（读、写、执行） 文件硬链接的次数 文件的属主(owner) 文件的属组(group) 文件的大小(size)，单位是字节 时间戳(timestamp)：最近一次被修改的时间 访问：access 修改：modify，文件内容发生改变 改变：change，metadata，元数据 文件名 -h:做单位转换，默认bit -a:显示以.开头的隐藏文件 . 表示当前目录 .. 表示父目录 -d：显示目录自身属性 -i：index node，inode -r：逆序显示文件 -R：递归(recursive)显示    进入目录
 cd /PATH cd ~USERNAME:进入指定用户的家目录 cd -:在当前目录和前一次所在目录之间来回切换    显示文件类型
 type /PATH/FILENAME    显示当前路径
 pwd    目录管理</description>
    </item>
    
    <item>
      <title></title>
      <link>https://cctrip.github.io/notes/docs/technology/system/linux/guideBook/permissionsOperation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cctrip.github.io/notes/docs/technology/system/linux/guideBook/permissionsOperation/</guid>
      <description>权限操作 #  权限 #    可读(r)(4)
  可写(w)(2)
  可执行(x)(1)
  特殊权限
  SUID(u+s): 运行某程序时，相应进程的属主是程序文件自身的属主
  SGID(g+s)：运行某程序时，相应进程的属组是程序文件自身的属组
  Sticky(o+t)：在一个公共目录，每个用户都可以创建删除自己的文件，但不能删除别人的文件
     用户和组 #    用户(UID)
  类别
  管理员：0
  普通用户：1-65535
  系统用户：1-499
  一般用户：500-65535
      配置文件
  /etc/passwd
字段详解(以&amp;quot;:&amp;ldquo;为分割符)
用户名 : 密码 : UID : GID : 注释 : 家目录 : 默认shell</description>
    </item>
    
  </channel>
</rss>
